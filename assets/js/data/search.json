[ { "title": "Colorindo Imagens Astronômicas em Python", "url": "/posts/Colorindo-imagens-astron%C3%B4micas/", "categories": "Python, Data, Astronomy, Image Processing", "tags": "python, data, image, astronomy", "date": "2023-01-01 00:00:00 +0000", "snippet": "Colorindo Imagens Astronômicas em PythonDurante a SIFSC12 foi realizado um minicurso do CAIFSCbaseado em um material que eu havia preparado para uma reunião do clube. Durante o curso eu prometi faz...", "content": "Colorindo Imagens Astronômicas em PythonDurante a SIFSC12 foi realizado um minicurso do CAIFSCbaseado em um material que eu havia preparado para uma reunião do clube. Durante o curso eu prometi fazer uma postagem no blog detalhando esse material. E então cá estamos!A proposta do curso é usar técnicas básicas de processamento de imagens para dar cor à imagens do James Webb Space Telescope(JWST). Para isso, vamos voltar um pouco e definir o que é uma imagemdigital.Imagens digitaisImagens são um tipo de informação bastante comum na experiência humana. Por isso, é interessantereproduzir, mesmo que de forma simplificada, essa informação. Pinturas, fotos e, nas últimas décadas, imagens digitais são uma expressão desse interesse.Imagens digitais são, de forma simplificada, representações de imagens que podem ser exibidas em ummonitor e, consequentemente, que podem ser armazenadas em um computador(acho que nem preciso dizerque são praticamente todas que você vê todos os dias). Existe mais de uma forma de se armazenar uma imagemnum computador, mas hoje vamos usar apenas uma: matrizes.Imagine que você queria explicar ao seu computador o que é uma imagem. Lembre-se, o seu computador só entendenúmeros e possui memória limitada(ele só consegue guardar uma quantidade finita de números). Uma possibilidadeseria dividir essa imagem em pequenos quadradinhos e atribuir números a esses quadradinhos. Esses quadradinhos seriam então elementos da imagem(em inglês picture element, ou pixel) e o número atribuido seria aintensidade desse pixel. A partir daí, basta guardar esses números em uma matriz nas posições corretas e agoratemos uma forma de mostrar essa imagem ao seu computador!Escala de cinza e RGBVocê talvez esteja se perguntando onde a cor entra nessa história(ou não). Bom, quando eu disse que cada posiçãoda matriz recebe um valor de intensidade, na verdade eu estava falando de um tipo específico de imagem: imagens emescala de cinza(grayscale). Esse tipo de imagem de fato só representa variações de intensidade(claro ou escuro) esão representadas, geralmente, em preto e branco. Cada pixel então é um valor num intervalo $[0,I_{max}]$,quando esse valor é $0$ o pixel é preto e quando o valor é $I_{max}$ o pixel é branco. Na vida real, podemos ter qualquer valor de intensidade nesse intevalo, mas, como eu já disse, o computador tem memória finita, entãotemos que dividir esse intevalo de forma discreta. Quanto mais dividirmos esse intervalo, melhor podemos representar variações sutis de intensidade. Você já deve ter ouvido falar em cores 8-bits e16-bits, pois bem, em 8-bits podemos ter $2^{8} = 256$ níveis de intensidade e em 16-bits podemoster $2^{16} = 65536$. Sistemas modernos usam 24-bits ou mais, faça as contas!Mas e as malditas cores? Bom, para isso, armazenamos em cada entrada da matriz mais de um número, cada um representandointensidades em escalas de cor diferentes(você pode imaginar que está misturando tinta e a intensidade representa a quantidade de tinta que vocês está misturando). Existem vários sistemas de cor, como o CMYK, utilizado em imagenscom a finalidade de impressão e, o sistema utilizado nesse curso, o RGB, onde cada pixel armazena informação de três canais de cor(vermelho, verde e azul).Imagens do JWSTO JWST capta imagens em escala de cinza. Sim, isso mesmo, o JWST, e telescópios em geral, captamimagens em preto e branco. Mas então como a NASA posta aquelas belas imagens todo dia no Instagram? Bom, é isso que viemos responder aqui.O JWST capta sinais em infra-vermelho. Esses sinais passam por filtros que separam frequências específicasdo espectro eletromagnético e então são “traduzidos” para frequências do intervalo visível do espectro. Podemosentão pegar os sinais correspondentes à partes de frequência mais baixa e associar ao vermelho e então fazer o mesmopor todo o espectro. Uma vez tendo os sinais correspondentes ao vermelho, verde e azul, podemos criar imagens coloridas!Simples? Pois é, tem alguns detalhes no meio dessa história, mas cuidaremos disso depois.Imagens em PythonAgora que já sabemos a teoria(mais ou menos), podemos começar a botar a mão na massa! Para isso utilizaremos a internacionalmente aclamada linguagem de programação Python. Para fins didáticos, esse curso utilizará apenasas bibliotecas numpy, matplotlib e os, mas existem bibliotecas mais sofisticadas para processamento de imagem, comoa scikit-image.Vamos importar essas bibliotecas e abrir as imagens correspondentes à diferentes filtros do JWST:import numpy as npimport matplotlib.pyplot as pltimport matplotlib.gridspec as gridspecimport osimgs = []#lista para armazenar as imagensfor img in sorted(os.listdir('./ngc3324/')):#para cada imagem no diretorio /ngc3324 if os.path.splitext(img)[1] == '.png':#se for um png print(img)#printa o nome da imagem imgs.append(plt.imread('./ngc3324/'+img))#guarda na lista de imagensA biblioteca matplotlib oferece a função imread, que permite abrir imagens em vários formatos.Para facilitar a visualização vamos criar uma função, mas não se preocupe com ela, é só um monte de “matplotlib-fu”:def show_img(img_list, nrow, ncol): fig = plt.figure(figsize=(5*(ncol+1), 5*(nrow+1))) gs = gridspec.GridSpec(nrow, ncol, wspace=0.05, hspace=0.0, top=1.-0.5/(nrow+1), bottom=0.5/(nrow+1), left=0.5/(ncol+1), right=1-0.5/(ncol+1)) idx = [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)] for i in range(ncol*nrow): ax = plt.subplot(gs[idx[i]]) ax.imshow(img_list[i], \"gray\") ax.set_xticks([]) ax.set_yticks([])Você pode então ver as imagens com:show_img(imgs, 2, 3)#2 e 3 são o número de linhas e colunasMuito emocionante, não? Não pare de ler, eu prometo que vai funcionar!Vamos investigar o que está acontecendo. Como será que estão distribuidas as intensidades dessas imagens?fig, axs = plt.subplots(2,3)idx = [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]for i in range(6): axs[idx[i]].hist(imgs[i].flatten())plt.tight_layout()Os histogramas das imagens apontam que a maioria dos pixels possuivalor baixo. E agora?Equalização de histogramaA primeira técnica de processamento de imagens que vamos utilizar é a equalização de histograma,uma técnica que permite aumentar o contraste de imagens.Essencialmente, queremos transformar uma imagem em k-bits de forma que o histograma fique “reto”, isto é, a probabilidade de obtermos um pixel com intensidade $n_{i}\\in[0,I_{max}]$ é mais ou menos a mesmapara qualquer $i\\in{1,2,…,k}$.Eu não vou me aprofundar em como fazer isso de fato, mas pretendo escrever sobre no futuro, aguardem!Em python, podemos escrever uma função razoavelmente simples que toma conta disso:def hist_eq(img, nbins=2**16): img_hist, bins = np.histogram(img.flatten(), nbins, density=True) cdf = img_hist.cumsum() cdf = (nbins-1) * cdf / cdf[-1] img_eq = np.interp(img.flatten(), bins[:-1], cdf) return img_eq.reshape(img.shape)Equalizando os histogramas e verificando os resultados:imgs = [np.array(hist_eq(i)) for i in imgs]fig, axs = plt.subplots(2,3)idx = [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]for i in range(6): axs[idx[i]].hist(imgs[i].flatten())plt.tight_layout()show_img(imgs, 2, 3)Bem melhor, não? Agora basta colocar uma imagem em cada canal e boom! Mas, espera aí…Combinando imagensBem, temos três canais e seis imagens, algo não cheira bem. E agora? Escolher três e jogar fora metade dessas belas imagens? Desistire ir chorar no banho? Não! Basta combinar duas imagens em uma! Podemos definir uma nova imagem a partir de duas: sejam duas imagens$M_{1}$ e $M_{2}$ e seus respectivos pixels $p_{ij}^{1}$ e $p_{ij}^{2}$. Definimos $M_{3}$ como a imagems com entradas $p_{ij}^{3} = f(p_{ij}^{1},p_{ij}^{2})$, onde $f:[0,I_{max}]\\times[0,I_{max}]\\to[0,I_{max}]$ é uma função dos pixels de $M_{1}$ e $M_{2}$. Confuso? Bom, talvez um exemplo facilite: podemos tirar a média pixel por pixel, ou pegar o maior valor. Com certeza existemescolhas melhores de $f$, mas para facilitar as nossas vidas, vamos apenas tirar a média das imagens:red = np.dstack([imgs[4],imgs[5]])red = red.mean(axis=2)red = (red - red.min())/(red.max() - red.min())green = np.dstack([imgs[2],imgs[3]])green = green.mean(axis=2)green = (green - green.min())/(green.max() - green.min())blue = np.dstack([imgs[0],imgs[1]])blue = blue.mean(axis=2)blue = (blue - blue.min())/(blue.max() - blue.min())channels = [red, green, blue]show_img(channels, 1, 3)Agora, podemos finalmente jogar uma imagem em cada canal e partir pro abraço, certo? Não.Algoritmo de LuptonApesar de representarem as frequências que corresponderiam às cores verde, vermelho e azul, é recomendável aindapreparar as imagens para que elas de fato componham os canais de cor. Um rapaz chamado Lupton propôs um algoritmo que faz essa preparação em imagens astronômicas. Essencialmente, é aplicada uma transformaçãonão-linear(envovendo um arcosseno hiperbólico) corrigida por um fator que nós podemos controlar(que é a verdadeirarazão de eu estar colocando isso aqui, já que se você ignorar essa parte, já é possível conseguir um resultado legal,mas estamos aqui para aprender, não é?). Esse método permite distinguir melhor objetos astronômicos ao garantir que objetos com cores específicas possuam uma cor distinta na imagem final. Recomendo a leitura do artigo original, érazoavelmente simples e é muito bem escrito.Enfim, podemos aplicar esse método assim:def asinh(img_src, non_linear=2.0): img = np.array(img_src, copy=True) scale_min = img.min() scale_max = img.max() factor = np.arcsinh((scale_max - scale_min)) img = np.arcsinh((img - scale_min)/non_linear)/factor return imgColorindo a imagem!Agora, podemos juntar tudo e criar nossa bela imagem da NGC3324:I = np.mean(channels, axis=0)new_channels = [channels[0]*asinh(I, non_linear = .99)/I, channels[1]*asinh(I, non_linear = .99)/I, channels[2]*asinh(I, non_linear = .99)/I]new_channels = np.clip(new_channels, 0, 1)color_img = np.dstack(new_channels)plt.figure(figsize=(10,10))ax = plt.subplot()ax.imshow(color_img, \"gray\")ax.set_xticks([])ax.set_yticks([])Pronto, temos cores! Você pode fazer algumas coisas agora: alterar o argumento non_linear e obter resultados diferentes; testar o código em outras imagens de telescópio; dormirEnfim, já falei demais. Até o próximo post(pode e vai demorar)!" }, { "title": "Minicurso Sifsc12", "url": "/posts/Minicurso-SIFSC12/", "categories": "", "tags": "", "date": "2022-10-11 00:00:00 +0000", "snippet": "Colorindo Imagens Astronômicas - SIFSC 12Baixem os dados aqui.Notebook, post e NGC3132 aqui(algum dia).copiem essas funções:def show_img(img_list, nrow, ncol): fig = plt.figure(figsize=(5*(ncol+...", "content": "Colorindo Imagens Astronômicas - SIFSC 12Baixem os dados aqui.Notebook, post e NGC3132 aqui(algum dia).copiem essas funções:def show_img(img_list, nrow, ncol): fig = plt.figure(figsize=(5*(ncol+1), 5*(nrow+1))) gs = gridspec.GridSpec(nrow, ncol, wspace=0.05, hspace=0.0, top=1.-0.5/(nrow+1), bottom=0.5/(nrow+1), left=0.5/(ncol+1), right=1-0.5/(ncol+1)) idx = [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)] for i in range(ncol*nrow): ax = plt.subplot(gs[idx[i]]) ax.imshow(img_list[i], \"gray\") ax.set_xticks([]) ax.set_yticks([])def hist_eq(img, nbins=2**16): img_hist, bins = np.histogram(img.flatten(), nbins, density=True) cdf = img_hist.cumsum() cdf = (nbins-1) * cdf / cdf[-1] img_eq = np.interp(img.flatten(), bins[:-1], cdf) return img_eq.reshape(img.shape)Playlist do curso" }, { "title": "Tutorial de Pandas", "url": "/posts/Tutorial-Pandas/", "categories": "Python, Data", "tags": "python, pandas, data", "date": "2022-06-30 00:00:00 +0000", "snippet": "Tutorial de PandasPandas:Pandas é uma biblioteca de Python para análise e manipulação de dados.Você pode instalar com pip:python -m pip install -U pandasRefazendo a última práticaPandas no Lab:Com ...", "content": "Tutorial de PandasPandas:Pandas é uma biblioteca de Python para análise e manipulação de dados.Você pode instalar com pip:python -m pip install -U pandasRefazendo a última práticaPandas no Lab:Com os dados da aula sobre labfis,podemos refazer algumas partes em poucas linhas:Primeiro, importamos a biblioteca:import pandas as pdVamos abrir os arquivos data1.dat e data2.dat e criar um dataframea partir deles. Dataframes são um tipo específico do pandas e sãobasicamente tabelas.data1 = pd.read_csv(\"data1.dat\", names=['data1'])data2 = pd.read_csv(\"data2.dat\", names=['data2'])df = pd.concat([data1,data2], axis=1)você verá algo como:O comando read_csv() serve para abrir arquivos com dados e, apesar donome, não precisamos usar apenas arquivos .csv. Caso você queria abrirum arquivo numa pasta diferente do seu arquivo .py ou notebook,é preciso passar o caminho completo.O argumento names serve para passarmos uma lista de nomes para as colunas do dataframe.Por fim, concat() concatena dois dataframes ao longo das linhas(axis=0)ou colunas(axis=1).Agora a primeira vantagem do pandas: podemos fazer o primeiro plot comum simples comando:df.plot()que nos retorna:Num total de 4 linhas temos um belo plot dos nossos dados!Também podemos plotar apenas uma coluna:df['data1'].plot()Também é possível passar uma lista de colunas.Podemos criar novas colunas simplesmente atribuindo dados à uma coluna com um novo nome. Como exemplo vamos criar duas novas colunas,uma com o desvio padrão e outra com a média:df['mean'] = df.mean(axis=1)df['std'] = df.std(axis=1)É possível fazer operações com as colunas:df['data1_norm'] = (df['data1'] - df['data1'].mean())/df['data1'].std()ou aplicar funções(inclusive do numpy!) ao dataframe:df['std_sqrd'] = df['std'].apply(lambda x:x**2)Por fim, podemos criar o gráfico com barras de erro. O método plot()também recebe qualquer argumento da função plot do matplotlib, então é possível colocar, por exemplo, um título:df['mean'].plot(yerr=df['std'], marker ='D', title='Errorbar plot')Isso é só o básico. Pandas pode ser tão complexo quanto seus dadosprecisarem e a documentaçãoé ótima.Exemplo Astronômico:A partir desses dados, em especial a tabela hygdata_v3.csv, vamos contruir o Diagrama HR.data = pd.read_csv('hygdata_v3.csv')df = pd.DataFrame(data)df.columnsfig = plt.figure( figsize=(8, 10), dpi=72)ax = fig.add_axes([.1, .1, .85, .8])ax.set_title('Hertzsprung-Russell Diagram', fontsize=18)ax.title.set_position([.5, 1.03])ax.set_xlabel('Color Index (B-V)')ax.set_ylabel('Absolute Magnitude')ax.scatter( df['ci'], df['absmag'], marker='.', s=[1] * len(df), c=df['ci'], cmap='inferno_r', linewidth=0)ax.set_facecolor('black')ax.scatter(0.656, 4,83, marker='.', c='red')ax.set_xlim(-.5, 2.5)ax.set_xticks(np.linspace(0, 2, 3, endpoint=True))ax.set_ylim(18, -16)ax.set_yticks(np.linspace(20, -10, 3, endpoint=True))" } ]
